# 编码问题

## 前置知识

### 字符集

为每一个字符分配一个唯一的 ID（学名为码位 / 码点 / Code Point）

### 编码规则

将码位转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）

## 不知真假的野史线

> 计算机设计之初使用8个可以开合的晶体管来组合成不同的状态
>
> 8个晶体管一共可以组合出256(2的8次方，下文中称0号-255号)种不同的状态（码位）

### ASCII「字符集」

* 开始计算机只有美国的兄弟们在用 

  他们把前32种状态分别规定了特殊的用途，起个名字 **控制码**；之后又加入了对空格、标点符号、数字、大小写字母等特定字符的编码，直到第127号状态。在之后一段时间内，这种编码规则的使用效果都还不错，给字符集起个名字： **`ASCII`** (American Standard Code for Information Interchange，美国信息互换标准代码)

* 慢慢全世界都在使用，咋办？🤔

  不是还有128-255号状态，用上！给128 到255号状态起个名字：”**扩展字符集**“

>...
>
>慢慢中国科技发展计算机普及，6000+常用汉字咋表示？
>
>...

### DBCS「双字节字符集」

> Double Byte Charecter Set  *一个汉字算两个英文字符* 的时代

#### GB2312

想了一个办法：小于127号的状态意义保持不变，把大于127号的两个状态连在一起表示一个汉字，前面的一个状态称之为 **高字节**，后面一个状态称之为 **低字节**，并将 ASCII 编码里本来就有的数字、标点、字母都用了两个状态表示，这就是常说的 **全角字符**，原来在127号之前的的称为**半角字符**。给字符集起个名字：**`GB2312`**

> ...
>
> 汉字他娘的太多了...
>
> ...

#### GBK

将低字节“必须是127号之后的状态”的规定撤销，只保证高字节是127号之后的状态即可。可表示的字符数量翻翻。妙阿🤨，给字符集起个名字：**`GBK`**(GBK即“国标”、“扩展”汉语拼音的第一个字母)

> ...
>
> 还不够？？
>
> ...

#### GB18030

忘了还有少数名族的文字😅，都给加上！给字符集起个名字：**`GB18030`**

>  ...
>
> 那沙特王国一个编码规则、印度阿三一个编码规则互相都不理解对方，是时候弄一个统一的编码规则
>
> ...

### Unicode「字符集」

> Universal Multiple-Octet Coded Character Set 简称 **UCS**，俗称 unicode

* **ISO**（国际标谁化组织）出马一个顶俩

  直接规定必须用两个状态，也就是16位来统一表示所有的字符

* **Little endian** / **Big endian**
  * Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做"零宽度非换行空格"（zero width no-break space），用 `FEFF` 表示。
  * 如果一个文本文件的头两个字节是 `FE FF`，就表示该文件采用大头方式；如果头两个字节是 `FF FE`，就表示该文件采用小头方式
  * 以汉字 `顺` 为例，它的Unicode 码是 987A。需要用两个字节存储：一个字节是98，另一个字节是7A。存储的时候98在前7A在后，则为Big endian 方式(`FE FF`)；存储的时候7A在前98在后，则为 Little endian 方式(`FF FE`)

* ⚠️注意

  * ***Unicode 字符集为每一个字符分配一个码位（与前文中提到的xxx号状态是一个概念），例如“知”字的码位是 30693，记作 U+77E5(30693的十六进制)***
  * ASCII里的那些“半角”字符在 unicode 中保持其原编码不变，只是将其长度由原来的8位扩展为16位，其他文化和语言的字符全部重新统一编码；
  * ”半角”英文符号只需要用到低8位，所以其高8位永远是0。
  * Unicode 无论是半角的英文字母还是全角的汉字，它们都是统一的**一个字符**，同时也都是统一的**两个字节**

  

### UTF「编码规则」

> UCS Transfer Format：unicode 编码的传输规则。
>
> 大白话解释🤔：怎么把代表符号的01二进制代码保存到计算机中，以适应不同的数据存储或传输方案

#### UTF-8

使用1至4个字节为每个字符编码

#### UTF-16

使用2至4个字节为每个字符编码

#### UTF-32 

使用4个字节为每个字符编码

## URL 字符转码

> Uniform Resource Identifier 统一资源标识符

### **为啥要编？**

> 为了统一编码标准（非英文字符会按照操作系统的字符集进行编码提交到服务器）

网络标准 **RFC 1738** 对URL格式做了硬性规定 👇

只有字母和数字[0-9a-zA-Z]、一些特殊符号$-_.+!*'(),、以及某些保留字，才可以不经过编码直接用于URL

### 怎么编？🌟

* 网址路径的编码，用的是utf-8编码（IE浏览器下）

* 查询字符串的编码，用的是操作系统的默认编码

* GET和POST方法的编码，用的是网页的编码

  ```html
  <!--根据网页的这个charset配置-->
  <meta http-equiv="Content-Type" content="text/html;charset=xxxx">
  ```

### JS 原生方法

***小知识：URI与URL的区别***

URI 在于Identifier，是统一资源标示符，可以唯一标识一个资源；URL在于Locater，一般来说（URL）统一资源定位符，可以提供找到该资源的路径，但URL又是URI，因为它可以标识一个资源，所以URL可以理解为是URI的子集

#### decodeURI()/encodeURI() 

> encodeURI() 函数利用当前字符 UTF-8  编码规则来对 URI 进行编码

该方法不会对 **ASCII 字母和数字 **进行编码，也不会对这些 ASCII 标点符号进行编码：**-_.!~*'()**，对以下在 URI 中具有特殊含义的 ASCII 标点符号也是不会进行转义的：**;/?:@&=+$,#**

```js
window.encodeURI("-_.!~*'()") // "-_.!~*'()"
window.encodeURI(";/?:@&=+$,#") // ";/?:@&=+$,#"
window.encodeURI("https://百度") // "https://%E7%99%BE%E5%BA%A6"（utf-8）
window.encodeURI("https://%E7%99%BE%E5%BA%A6") // "https://百度"
```

#### decodeURIComponent()/encodeURIComponent()

与 encodeURI() 的区别是，encodeURIComponent() 不会对 **ASCII字母和数字 -_.!~*'()** 进行编码，也就是说比encodeURI() 的编码范围更广了～

```js
//可以和👆上边的例子进行对比
window.encodeURIComponent(";/?:@&=+$,#") //"%3B%2F%3F%3A%40%26%3D%2B%24%2C%23"
window.encodeURIComponent("https://百度") //"https%3A%2F%2F%E7%99%BE%E5%BA%A6"
```

注意⚠️：

1. encodeURIComponent() 的使用场景为：将 url（特殊字符）作为参数传递
2. encodeURI() 的使用场景为：将整个URL进行编码，需要使用编码后的URL

## 课外知识

> 几个和编码相关的知识点；都是未将 `数据` 在 `特定环境下` 转换为`指定编码格式` 时产生BUG的场景

### XSS 跨站脚本攻击(Cross Site Scripting)

> 为啥叫 XSS 不叫 CSS ？你不觉得 CSS 很眼熟？CSS是层叠样式表阿(Cascading Style Sheets)，为了避免混淆叫 XSS 吧

成功步骤：

1. 想办法在页面植入一段js恶意代码
2. 让用户无意间访问植入了恶意代码的页面
3. 获取他的cookie，登陆他的账号，用他的钱，和他的女朋友聊天 👍

注意⚠️：

XSS 结合 CSRF 跨站请求伪造攻击，利用 XSS 先获取你的登陆信息 + 抓包转账 or 修改密码的地址，然后啥事都办成了。CSRF 单独使用需要用户进入页面或者点击某个按钮来触发恶意链接的调用

### 格式化字符串漏洞 

感兴趣看看 [传送门](https://zhuanlan.zhihu.com/p/75951259)，主要是利用 printf、sprintf、fprintf 等 print 家族函数设计上的漏洞

### SQL 注入

通过把恶意的 sql 语句插入到网站的表单提交或者输入域名请求的查询语句，最终达到欺骗网站的服务器执行恶意的 sql 语句

updating...



